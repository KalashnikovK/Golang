/*
Давайте используем ваши знания структур, методов и интерфейсов на практике и реализуем объект, удовлетворяющий интерфейсу fmt.Stringer. Назовем его "Батарейка".

Во-первых, вы должны объявить новый тип, удовлетворяющий интерфейсу fmt.Stringer.
Ваш тип должен предусматривать, что на печати он будет выглядеть так: [      XXXX]: где пробелы - "опустошенная" емкость батареи, а X - "заряженная".

Во-вторых, на стандартный ввод вы получаете строку, состоящую ровно из 10 цифр: 0 или 1 (порядок 0/1 случайный).
Ваша задача считать эту строку любым возможным способом и создать на основе этой строки объект объявленного вами на первом этапе типа:
надеюсь, вы понимаете, что строка символизирует емкость батарейки: 0 - это "опустошенная" часть, а 1 - "заряженная".

В-третьих, созданный вами объект должен называться batteryForTest (использование этого имени обязательно).
В вашем распоряжении фактически весь файл, НО завершающая фигурная скобка функции main() вам не видна, но она присутствует.
Перед этой скобкой присутствует функция (которая вам тоже не видна), принимающая в качестве аргумента объект типа fmt.Stringer - batteryForTest,
и направляющая его на стандартный вывод, поэтому вам не требуется выводить что-то на печать самостоятельно.

Удачи!

Sample Input:
1000010011

Sample Output:
[      XXXX]
*/

package main

// в степик нужно от сих. Потому что там импортирован только пакет fmt, нужно еще импортировать strings
import (
	"fmt"
	"strings"
)

type Battery struct {
	str string
}

func (b Battery) String() string {
	quantX := strings.Count(b.str, "1")
	quantS := 10 - quantX

	return fmt.Sprintf("[%s%s]", strings.Repeat(" ", quantS), strings.Repeat("X", quantX))
}

func main() {
	var text string
	fmt.Scan(&text)
	batteryForTest := Battery{str: text}

	// до сих. !!! Закрывающую скобку main тоже НЕ НАДО. Читай условие задачи.
	fmt.Print(batteryForTest)
}
